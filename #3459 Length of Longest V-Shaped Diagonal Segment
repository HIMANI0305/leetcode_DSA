class Solution {
    private int m, n;
    private int[][] grid;
    private int[][][][][] memo;
    
   
    private final int[][] DIRS = {{-1, 1}, {1, 1}, {1, -1}, {-1, -1}};
    public int lenOfVDiagonal(int[][] grid) {
        this.grid = grid;
        m = grid.length;
        n = grid[0].length;
        
        
        memo = new int[m][n][4][2][3];
        for (int[][][][] a : memo)
            for (int[][][] b : a)
                for (int[][] c : b)
                    for (int[] d : c)
                        Arrays.fill(d, -1);
        
        int ans = 0;
        
       
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) {
                    for (int d = 0; d < 4; d++) {
                        int ni = i + DIRS[d][0];
                        int nj = j + DIRS[d][1];
                        ans = Math.max(ans, 1 + dfs(ni, nj, d, 0, 2)); // after 1, expect 2
                    }
                }
            }
        }
        return ans;
    }
    
    private int dfs(int i, int j, int dir, int turned, int expected) {
        
        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != expected) {
            return 0;
        }
        
        if (memo[i][j][dir][turned][expected] != -1) {
            return memo[i][j][dir][turned][expected];
        }
        
        int nextExpected = (expected == 2) ? 0 : 2; 
        
       
        int ni = i + DIRS[dir][0];
        int nj = j + DIRS[dir][1];
        int res = 1 + dfs(ni, nj, dir, turned, nextExpected);
        
       
        if (turned == 0) {
            int newDir = (dir + 1) % 4; 
            int nni = i + DIRS[newDir][0];
            int nnj = j + DIRS[newDir][1];
            res = Math.max(res, 1 + dfs(nni, nnj, newDir, 1, nextExpected));
        }
        
        return memo[i][j][dir][turned][expected] = res;
    }
}
